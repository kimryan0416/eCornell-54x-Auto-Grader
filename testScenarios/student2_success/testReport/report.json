{
  "stats": {
    "suites": 3,
    "tests": 3,
    "passes": 3,
    "pending": 0,
    "failures": 0,
    "start": "2019-01-25T09:25:54.554Z",
    "end": "2019-01-25T09:25:59.725Z",
    "duration": 5171,
    "testsRegistered": 3,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "passPercentClass": "success",
    "pendingPercentClass": "danger"
  },
  "suites": {
    "uuid": "c0ea5a13-c813-497d-8508-65151da25a91",
    "title": "",
    "fullFile": "",
    "file": "",
    "beforeHooks": [],
    "afterHooks": [],
    "tests": [],
    "suites": [
      {
        "uuid": "6f051a24-3dd9-44fb-999a-04a6331ad786",
        "title": "Validate HTML File NO SUPPRESS",
        "fullFile": "/Users/RK/Desktop/MAMP_WEB/cis54x/cis54xPackages/runner.js",
        "file": "/runner.js",
        "beforeHooks": [
          {
            "title": "\"before all\" hook",
            "fullTitle": "Validate HTML File NO SUPPRESS \"before all\" hook",
            "timedOut": false,
            "duration": 1846,
            "pass": false,
            "fail": false,
            "pending": false,
            "code": "this.timeout(20000);\t// set timeout of test to 20,000 milliseconds (20 seconds)\n\n/* --- STEP 2.1: child process executes java command to find HTML errors --- */\nvar child = exec('java -jar '+vnuPath+' --skip-non-html --format json --errors-only '+ htmlPath, function (error, stdout, stderr){\n\t/* --- STEP 2.2: first parse errors as JSON, then filter out 'expected doctype' and 'missing title' errors if necessary - Use 'messages' global variable to refer to returned errors --- */\n\tvar parsedErrors = JSON.parse(stderr);\n\tmessages = (suppress) ? parsedErrors.messages.filter(mes=>{\n\t\tvar newMes = mes.message.toLowerCase().replace(/[^a-zA-Z ]/g, '');\n\t\tif ( (newMes.indexOf('expected doctype html') == -1) && (newMes.indexOf('element head is missing a required instance of child element title') == -1) ) return mes;\n\t}) : parsedErrors.messages;\n\tdone();\n});",
            "err": {},
            "isRoot": false,
            "uuid": "0c61cc1f-5afa-47b6-8218-d634e4624531",
            "isHook": true,
            "skipped": false
          }
        ],
        "afterHooks": [
          {
            "title": "\"after each\" hook",
            "fullTitle": "Validate HTML File NO SUPPRESS \"after each\" hook",
            "timedOut": false,
            "duration": 1,
            "pass": false,
            "fail": false,
            "pending": false,
            "code": "if (messages.length > 0) {\n\t\n\tvar parsedMessages = {}, errors = '';\n\t// parsedMessages = object storing each file's errors, compiled into a string per file\n\t// errors = string to be printed to mochawesome, compiles all errors into one single string\n\t/* --- STEP 4.1: Reduce all errors per file into a string, and saves new object of strings into 'parsedMessages' --- */\n\tmessages.forEach(mes=>{\n\t\tvar thisURL = mes.url.replace(process.cwd(), '').replace('file:/','');\n\t\tparsedMessages[thisURL] = (typeof parsedMessages[thisURL] === 'undefined') ? '' : parsedMessages[thisURL];\n\t\tparsedMessages[thisURL] += '- ' + forceUnicodeEncoding('[Line '+mes.lastLine+']: '+ mes.message) + '\\n';\n\t\treturn;\n\t});\n\t/* --- STEP 4.2: Reduce 'parsedMessages' into one string, 'errors' --- */\n\tObject.keys(parsedMessages).forEach(file => {\terrors += 'FILE: \"'+file+'\"\\n' + parsedMessages[file];\t});\n\t/* --- STEP 4.3: send errors to mochawesome as CONTEXT for this test --- */\n\tthis.currentTest.context = {'title':'Error Messages','value':errors};\n}\ndone();",
            "err": {},
            "isRoot": false,
            "uuid": "dbc5c20a-6362-44bd-9a32-ae870bdc9322",
            "isHook": true,
            "skipped": false
          }
        ],
        "tests": [
          {
            "title": "Expecting no HTML errors",
            "fullTitle": "Validate HTML File NO SUPPRESS Expecting no HTML errors",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "expect(messages.length, errorStatement).to.equal(0);\ndone();",
            "err": {},
            "isRoot": false,
            "uuid": "52f78e87-9cc5-4fa0-8541-3015459d9ff4",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "52f78e87-9cc5-4fa0-8541-3015459d9ff4"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 1,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "411611f1-1209-43a3-960f-c4de1a6564eb",
        "title": "Validate HTML File SUPPRESS",
        "fullFile": "/Users/RK/Desktop/MAMP_WEB/cis54x/cis54xPackages/runner.js",
        "file": "/runner.js",
        "beforeHooks": [
          {
            "title": "\"before all\" hook",
            "fullTitle": "Validate HTML File SUPPRESS \"before all\" hook",
            "timedOut": false,
            "duration": 1673,
            "pass": false,
            "fail": false,
            "pending": false,
            "code": "this.timeout(20000);\t// set timeout of test to 20,000 milliseconds (20 seconds)\n\n/* --- STEP 2.1: child process executes java command to find HTML errors --- */\nvar child = exec('java -jar '+vnuPath+' --skip-non-html --format json --errors-only '+ htmlPath, function (error, stdout, stderr){\n\t/* --- STEP 2.2: first parse errors as JSON, then filter out 'expected doctype' and 'missing title' errors if necessary - Use 'messages' global variable to refer to returned errors --- */\n\tvar parsedErrors = JSON.parse(stderr);\n\tmessages = (suppress) ? parsedErrors.messages.filter(mes=>{\n\t\tvar newMes = mes.message.toLowerCase().replace(/[^a-zA-Z ]/g, '');\n\t\tif ( (newMes.indexOf('expected doctype html') == -1) && (newMes.indexOf('element head is missing a required instance of child element title') == -1) ) return mes;\n\t}) : parsedErrors.messages;\n\tdone();\n});",
            "err": {},
            "isRoot": false,
            "uuid": "bb41a2c9-6a8c-42e2-94ab-6cdbe60e7295",
            "isHook": true,
            "skipped": false
          }
        ],
        "afterHooks": [
          {
            "title": "\"after each\" hook",
            "fullTitle": "Validate HTML File SUPPRESS \"after each\" hook",
            "timedOut": false,
            "duration": 0,
            "pass": false,
            "fail": false,
            "pending": false,
            "code": "if (messages.length > 0) {\n\t\n\tvar parsedMessages = {}, errors = '';\n\t// parsedMessages = object storing each file's errors, compiled into a string per file\n\t// errors = string to be printed to mochawesome, compiles all errors into one single string\n\t/* --- STEP 4.1: Reduce all errors per file into a string, and saves new object of strings into 'parsedMessages' --- */\n\tmessages.forEach(mes=>{\n\t\tvar thisURL = mes.url.replace(process.cwd(), '').replace('file:/','');\n\t\tparsedMessages[thisURL] = (typeof parsedMessages[thisURL] === 'undefined') ? '' : parsedMessages[thisURL];\n\t\tparsedMessages[thisURL] += '- ' + forceUnicodeEncoding('[Line '+mes.lastLine+']: '+ mes.message) + '\\n';\n\t\treturn;\n\t});\n\t/* --- STEP 4.2: Reduce 'parsedMessages' into one string, 'errors' --- */\n\tObject.keys(parsedMessages).forEach(file => {\terrors += 'FILE: \"'+file+'\"\\n' + parsedMessages[file];\t});\n\t/* --- STEP 4.3: send errors to mochawesome as CONTEXT for this test --- */\n\tthis.currentTest.context = {'title':'Error Messages','value':errors};\n}\ndone();",
            "err": {},
            "isRoot": false,
            "uuid": "f7623a95-aee1-4e0b-9816-59ec80bad291",
            "isHook": true,
            "skipped": false
          }
        ],
        "tests": [
          {
            "title": "Expecting no HTML errors",
            "fullTitle": "Validate HTML File SUPPRESS Expecting no HTML errors",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "expect(messages.length, errorStatement).to.equal(0);\ndone();",
            "err": {},
            "isRoot": false,
            "uuid": "e3794582-6fe7-492f-b3f9-65fb22c4eaaa",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "e3794582-6fe7-492f-b3f9-65fb22c4eaaa"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 1,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "6559970f-d611-4108-b6fa-603143a08dd0",
        "title": "Validate HTML File SUCCESS",
        "fullFile": "/Users/RK/Desktop/MAMP_WEB/cis54x/cis54xPackages/runner.js",
        "file": "/runner.js",
        "beforeHooks": [
          {
            "title": "\"before all\" hook",
            "fullTitle": "Validate HTML File SUCCESS \"before all\" hook",
            "timedOut": false,
            "duration": 1639,
            "pass": false,
            "fail": false,
            "pending": false,
            "code": "this.timeout(20000);\t// set timeout of test to 20,000 milliseconds (20 seconds)\n\n/* --- STEP 2.1: child process executes java command to find HTML errors --- */\nvar child = exec('java -jar '+vnuPath+' --skip-non-html --format json --errors-only '+ htmlPath, function (error, stdout, stderr){\n\t/* --- STEP 2.2: first parse errors as JSON, then filter out 'expected doctype' and 'missing title' errors if necessary - Use 'messages' global variable to refer to returned errors --- */\n\tvar parsedErrors = JSON.parse(stderr);\n\tmessages = (suppress) ? parsedErrors.messages.filter(mes=>{\n\t\tvar newMes = mes.message.toLowerCase().replace(/[^a-zA-Z ]/g, '');\n\t\tif ( (newMes.indexOf('expected doctype html') == -1) && (newMes.indexOf('element head is missing a required instance of child element title') == -1) ) return mes;\n\t}) : parsedErrors.messages;\n\tdone();\n});",
            "err": {},
            "isRoot": false,
            "uuid": "edf40f3e-5dc5-42ca-9d5f-a8c80d415e0c",
            "isHook": true,
            "skipped": false
          }
        ],
        "afterHooks": [
          {
            "title": "\"after each\" hook",
            "fullTitle": "Validate HTML File SUCCESS \"after each\" hook",
            "timedOut": false,
            "duration": 0,
            "pass": false,
            "fail": false,
            "pending": false,
            "code": "if (messages.length > 0) {\n\t\n\tvar parsedMessages = {}, errors = '';\n\t// parsedMessages = object storing each file's errors, compiled into a string per file\n\t// errors = string to be printed to mochawesome, compiles all errors into one single string\n\t/* --- STEP 4.1: Reduce all errors per file into a string, and saves new object of strings into 'parsedMessages' --- */\n\tmessages.forEach(mes=>{\n\t\tvar thisURL = mes.url.replace(process.cwd(), '').replace('file:/','');\n\t\tparsedMessages[thisURL] = (typeof parsedMessages[thisURL] === 'undefined') ? '' : parsedMessages[thisURL];\n\t\tparsedMessages[thisURL] += '- ' + forceUnicodeEncoding('[Line '+mes.lastLine+']: '+ mes.message) + '\\n';\n\t\treturn;\n\t});\n\t/* --- STEP 4.2: Reduce 'parsedMessages' into one string, 'errors' --- */\n\tObject.keys(parsedMessages).forEach(file => {\terrors += 'FILE: \"'+file+'\"\\n' + parsedMessages[file];\t});\n\t/* --- STEP 4.3: send errors to mochawesome as CONTEXT for this test --- */\n\tthis.currentTest.context = {'title':'Error Messages','value':errors};\n}\ndone();",
            "err": {},
            "isRoot": false,
            "uuid": "7f0364b1-57d8-4cd2-a861-295adcccb53a",
            "isHook": true,
            "skipped": false
          }
        ],
        "tests": [
          {
            "title": "Expecting no HTML errors",
            "fullTitle": "Validate HTML File SUCCESS Expecting no HTML errors",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "expect(messages.length, errorStatement).to.equal(0);\ndone();",
            "err": {},
            "isRoot": false,
            "uuid": "7c038613-2d08-4862-8666-44af4444eba5",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "7c038613-2d08-4862-8666-44af4444eba5"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 0,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      }
    ],
    "passes": [],
    "failures": [],
    "pending": [],
    "skipped": [],
    "duration": 0,
    "root": true,
    "rootEmpty": true,
    "_timeout": 20000
  },
  "copyrightYear": 2019
}